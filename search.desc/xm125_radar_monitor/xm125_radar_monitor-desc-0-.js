searchState.loadedDescShard("xm125_radar_monitor", 0, "Configure distance measurement range\nConfigure presence parameters for the radar\nDebug registers if radar is connected, with automatic …\nDisplay distance measurement result\nDisplay presence detection result\nExecute the main command logic\nHandle bootloader command\nHandle firmware-related commands\nHandle firmware checksum command\nHandle firmware erase command\nHandle GPIO commands\nApplication entry point\nMonitor distance measurements continuously\nMonitor presence detection continuously\nMain application logic\nPut XM125 module into bootloader mode for firmware …\nCheck current firmware type and version\nCalculate and display firmware checksums\nComma-separated values for data analysis\nPerform distance measurement\nErase the XM125 chip completely\nFirmware management commands\nGPIO control and testing commands\nHuman-readable output with labels and units (default)\nGet XM125 device information and firmware details\nInitialize GPIO pins and show status\nJSON format for programmatic processing\nLong range: 50cm to 7m (maximum detection range)\nMedium range: 20cm to 2m (balanced range and sensitivity)\nPerform presence detection\nReset XM125 to bootloader mode\nReset XM125 to run mode\nShort range: 6cm to 70cm (good for close proximity …\nCheck XM125 radar status and initialization state\nShow current GPIO pin status\nTest bootloader control functionality\nUpdate firmware to match the specified detector mode\nVerify firmware integrity using checksums\nLog all register values after configuration for comparison …\nFirmware directory path (contains .bin files)\nOutput format for measurement data\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet GPIO pin configuration from command line arguments\nGet the I2C device path, using bus number if device path …\nGPIO pin for XM125 bootloader control (BOOT0)\nGPIO pin for XM125 MCU interrupt (input)\nGPIO pin for XM125 reset control (active-low)\nGPIO pin for XM125 wake up control\nI2C address of XM125 module in hex (e.g., 0x52 for …\nI2C bus number (will be used as /dev/i2c-N if –…\nI2C device path (e.g., /dev/i2c-2 for Sentai target)\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nParse I2C address from string, supporting both decimal and …\nSuppress startup banner and configuration info\nCommand timeout in seconds (how long to wait for device …\nEnable verbose debug logging (shows I2C transactions and …\nEnable continuous monitoring mode\nEnable continuous monitoring mode\nNumber of measurements in continuous mode (omit for …\nNumber of measurements in continuous mode (omit for …\nFrame rate for presence detection in Hz\nMeasurement interval in milliseconds for continuous mode\nMeasurement interval in milliseconds for continuous mode\nMaximum detection range in meters (custom range)\nMinimum detection range in meters (custom range)\nDetection range in meters (format: start:end, e.g., …\nPresence detection range preset\nSave measurements to CSV file (continuous mode only)\nSave measurements to CSV file (continuous mode only)\nDetection sensitivity threshold (0.1 = low, 0.5 = medium, …\nConfirm the erase operation (required for safety)\nTarget firmware type (distance or presence)\nFirmware type to verify against\nSpecific firmware type to checksum (if not specified, …\nForce update even if firmware already matches\nReset to run mode after entering bootloader (for testing)\nShow detailed information including file paths and sizes\nVerify firmware after update (adds delay and may timeout)\nContains the error value\nContains the success value\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nXM125 Firmware Manager\nFirmware types supported by XM125\nGet the application ID expected for this firmware type\nGet the firmware binary filename\nCalculate MD5 checksum of a firmware binary file\nCheck if the control script exists and is accessible\nGet human-readable name\nPut XM125 into bootloader mode\nErase the XM125 chip completely\nCheck if firmware update is needed\nFlash firmware using stm32flash\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert application ID to firmware type\nGet MD5 checksum of currently flashed firmware\nGet full path to firmware binary\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate new firmware manager\nReset XM125 to run mode\nUpdate firmware to the specified type (without …\nUpdate firmware with optional verification\nVerify device is in run mode by checking I2C bus\nVerify firmware was flashed correctly\nGPIO direction enumeration\nGPIO value enumeration\nXM125 GPIO Controller\nXM125 GPIO pin definitions for i.MX8MM platform\nBoot pin - <code>GPIO5_IO13</code> (128+13=141) - Bootloader control\nExport GPIO if not already exported\nFix GPIO141 bootloader pin (Foundries.io workaround) This …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet GPIO value\nInitialize all XM125 GPIO pins\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if GPIO controller is initialized\nMCU interrupt pin - <code>GPIO4_IO29</code> (96+29=125) - Module ready …\nCreate a new GPIO controller with default pin configuration\nPerform the actual reset sequence (common for both modes)\nGet pin configuration\nReset pin - <code>GPIO4_IO28</code> (96+28=124) - Active-low reset\nReset XM125 module to bootloader mode\nReset XM125 module to run mode\nSet XM125 to bootloader mode (without reset)\nSet GPIO direction\nSet GPIO value\nSet XM125 to run mode (without reset)\nShow current GPIO status\nTest bootloader control functionality\nTry to export a GPIO pin\nUnbind SPI controller\nUnbind SPI device\nWait for MCU interrupt to go HIGH (module ready)\nWake up pin - <code>GPIO5_IO11</code> (128+11=139) - Wake up control\nCreate a new GPIO controller with custom pin configuration\nConfigure GPIO pins for XM125 hardware control\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCheck if the XM125 module is ready (INT pin HIGH)\nPut the XM125 module into low power mode\nWake up the XM125 module using hardware pins\nConfigure distance detector\nConfigure distance range from string (e.g., “0.1:3.0”)\nConfigure presence detector\nConfigure presence range (for backward compatibility with …\nConnect to XM125 radar module with automatic reset if …\nDebug registers\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet detector mode\nGet device information\nGet formatted status string\nGet raw status from device\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if radar is connected\nMeasure distance\nMeasure presence\nRead application ID (for firmware compatibility)\nReset XM125 to run mode using internal GPIO control\nSet detector mode\nStart presence detector\nStop presence detector\nDebug all registers based on detector mode\nDebug all common registers\nDebug distance detector registers\nDebug presence detector registers\nDebug a single register\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nApply configuration and calibrate\nConfigure distance detector with default settings\nConfigure distance range\nReturns the argument unchanged.\nReturns the argument unchanged.\nCheck if distance detector has errors\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if distance detector is busy\nMeasure distance\nReset the distance module\nWait for distance detector to not be busy\nWrite command safely with busy/error checking\nApply the complete configuration including range settings\nApply configuration (section 2.3.3 compliance)\nCalculate optimal profile based on detection range\nCalculate optimal step length based on maximum range\nCheck if configuration was applied successfully (from …\nConfigure presence range according to datasheet …\nConfigure thresholds and frame rate\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCheck if presence detector has errors (section 2.3.1 …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if presence detector is busy (section 2.3.1 …\nMeasure presence detection\nReset the presence detector module (needed to make a new …\nStart presence detector (section 2.3.4 compliance)\nStop presence detector (section 2.3.4 compliance)\nWait for detector to not be busy (from example code)\nWrite command safely with busy/error checking (section …")